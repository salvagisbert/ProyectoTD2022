---
title: " ProyectoTD2022"
subtitle: "Tratamiento de Datos. Grado en Ciencia de Datos- UV"
author: "Grupo H"
date:  "`r Sys.Date()`" 
params:
  lang: ES
lang: "`r switch(params$lang, ES = 'es-ES', EN = 'en-US')`"
output:
  html_document:
    
    echo: yes
    number_sections: yes
    theme: lumen     
    toc: yes
  pdf_document:
    
    toc: yes      
    toc_depth: 3  
  html_notebook:
    
    echo: yes
    number_sections: yes
    toc: yes
language:
  label:
    fig: 'Figura '
    tab: 'Tabla '
    eq: 'Ecuación '
    thm: 'Teorema '
    lem: 'Lema '
    def: 'Definición '
    cor: 'Corolario '
    prp: 'Proposición '
    exm: 'Ejemplo '
    exr: 'Ejercicio '
    proof: 'Demostración. '
    remark: 'Nota: '
    solution: 'Solución. '
---
# Configuración del los bloques (*Chunks*)

```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}

# CONFIGURACIÓN GENERAL
library(knitr)
options(width = 100)

# Opciones generales de los chucks. Se utilizarán salvo cambios en el chunk
opts_chunk$set(echo=F, message = F, error = F, warning = F, comment = NA, fig.align = 'center', dpi = 200, tidy = F, cache.path = '.cache/', fig.path = './figura/')

# Opciones generales de dígitos cuando se incluyen tablas
#options(xtable.type = 'html')
knit_hooks$set(inline = function(x) {
  
  if(is.numeric(x)) {
    round(x, getOption('digits'))
  } else {
    paste(as.character(x), collapse = ', ')
  }
})
#knit_hooks$set(plot = knitr:::hook_plot_html)
```

# Instalación automática de paquetes

Especificar las librerías necesarias para ejecutar el código en la variable ***packages***. Si no está instaladas, se instalarán y cargarán (solo para aquellas que están en el repositorio <http://cran.rediris.es>)

El siguiente bloque, al no especificar opciones del *chunk* usa la configuración por defecto.

```{r}

# Especificamos las librerías necesarias en esta lista

packages = c("tidyverse","knitr","tidyverse", "readr", "ggplot2", "dplyr", "tidyr", "lubridate")

#use this function to check if each package is on the local machine
#if a package is installed, it will be loaded
#if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
  }
  library(x, character.only = TRUE)
})

#verify they are loaded
search()

```

#Introducción:

  El objetivo de este proyecto es que nos enfrentemos a un problema de tratamiento de datos que abarque todas las etapas que estamos describiendo a lo largo del curso. Analizaremos los datos recogidos por sensores que monitorizan el nivel de ruido en diferentes localizaciones del barrio de Ruzafa. 

  
#FASE 3. Importación de los datos

  Para comenzar a analizar los datos, debemos primero importarlos.

```{r}
Cadiz_3 <- read.csv("data/Cadiz_3.csv")
Cadiz_3<- mutate(Cadiz_3, c="Cadiz_3")

Cadiz_16 <- read.csv("data/Cadiz_16.csv")
Cadiz_16<- mutate(Cadiz_16, c="Cadiz_16")

CarlesCervera_34 <- read.csv("data/CarlesCervera_34.csv")
CarlesCervera_34<- mutate(CarlesCervera_34, c="CarlesCervera_34")

CarlesCervera_Chaf_ReinaDonyaMaria <- read.csv("data/CarlesCervera_Chaf_ReinaDonyaMaria.csv")
CarlesCervera_Chaf_ReinaDonyaMaria<- mutate(CarlesCervera_Chaf_ReinaDonyaMaria, c="CarlesCervera_Chaf_ReinaDonyaMaria")

Cuba_3 <- read.csv("data/Cuba_3.csv")
Cuba_3<- mutate(Cuba_3, c="Cuba_3")

DoctorSerrano_21 <- read.csv("data/DoctorSerrano_21.csv")
DoctorSerrano_21<-mutate(DoctorSerrano_21, c="DoctorSerrano_21")

GeneralPrim_Chaf_DonosoCortes <- read.csv("data/GeneralPrim_Chaf_DonosoCortes.csv")
GeneralPrim_Chaf_DonosoCortes<- mutate(GeneralPrim_Chaf_DonosoCortes, c="GeneralPrim_Chaf_DonosoCortes")

PuertoRico_21 <- read.csv("data/PuertoRico_21.csv")
PuertoRico_21<- mutate(PuertoRico_21, c="PuertoRico_21")

SalvadorAbril_Chaf_Maestro_JoseSerrano <- read.csv("data/SalvadorAbril_Chaf_Maestro_JoseSerrano.csv")

SalvadorAbril_Chaf_Maestro_JoseSerrano<- mutate(SalvadorAbril_Chaf_Maestro_JoseSerrano, c="SalvadorAbril_Chaf_Maestro_JoseSerrano")

Sueca_2 <- read.csv("data/Sueca_2.csv")
Sueca_2<- mutate(Sueca_2, c="Sueca_2")

Sueca_32 <- read.csv("data/Sueca_32.csv")
Sueca_32<- mutate(Sueca_32, c="Sueca_32")

Sueca_61 <- read.csv("data/Sueca_61.csv")
Sueca_61<- mutate(Sueca_61, c="Sueca_61")

Sueca_Esq_Denia <- read.csv("data/Sueca_Esq_Denia.csv")
Sueca_Esq_Denia<-mutate(Sueca_Esq_Denia, c="Sueca_Esq_Denia")

Vivons_Chaf_Cadiz <- read.csv("data/Vivons_Chaf_Cadiz.csv")
Vivons_Chaf_Cadiz<- mutate(Vivons_Chaf_Cadiz, c="Vivons_Chaf_Cadiz")
```
#FASE 4. Se juntan los data frames en uno solo.

```{r}
datos <- rbind(Cadiz_3, rbind(Cadiz_16, rbind(CarlesCervera_34, rbind(CarlesCervera_Chaf_ReinaDonyaMaria, rbind(Cuba_3, rbind(DoctorSerrano_21, rbind(GeneralPrim_Chaf_DonosoCortes, rbind(PuertoRico_21, rbind(SalvadorAbril_Chaf_Maestro_JoseSerrano, rbind(Sueca_2, rbind(Sueca_32, rbind(Sueca_61, rbind(Sueca_Esq_Denia, rbind(Vivons_Chaf_Cadiz)))))))))))))) 

```


Analisis inicial de los datos.

```{r}
summary(datos)
glimpse(datos)
```
1) ¿Cuántas variables o columnas tiene el data frame?

El DataFrame "datos" tiene 8 variables, que son el id, tiempo_grabacion, r_continuo, r_7a19, r_tardenoche, r_19a23, r_23a7 y fecha_observacion.

2) ¿Los datos son fácilmente accesibles?

Si, porque si observamos el Data Frame, se ve claramente y a simple vista la información.

3) ¿Que datos podemos observar en este data frame?

En el Data Frame observamos los datos recogidos por sensores que monitorizan el nivel de ruido en diferentes localizaciones del barrio de Ruzafa.

4) ¿Hay datos perdidos?¿Es un analisis univariante o bivariante?

Si que hay datos perdidos y, es un análisis bivariante ya que tenemos más de una variable.

Variacion del ruido entre las 7h y las 19h durante los meses del año dividido en años
```{r}
datos2 <- separate(datos, col = dateObserved, into = c("year", "month", "day"), sep = "-")
datos2 %>% group_by(month) %>% 
  ggplot(aes(x = month, y = LAeq_d, col = month)) + geom_line(aes(size=1)) + labs(x = "Meses", y = "Ruido entre las 7h y las 19h") + facet_grid(year~.)
datos2 %>% group_by(month) %>% 
  ggplot(aes(x = month, y = LAeq_e, col = month)) + geom_line(aes(size=1)) + labs(x = "Meses", y = "Ruido entre las 19h y las 23h") + facet_grid(year~.)
datos2 %>% group_by(month) %>% 
  ggplot(aes(x = month, y = LAeq_n, col = month)) + geom_line(aes(size=1)) + labs(x = "Meses", y = "Ruido entre las 23h y las 7h") + facet_grid(year~.)
```


Medicion de ruido durante diferentes franjas horarias del dia de marzo(fallas), es el mes que mas ruido hay en Ruzafa durante el año.
```{r}
datos2$day <- as.numeric(datos2$day)
datos2$month <- as.numeric(datos2$month)
datos2$year <- as.numeric(datos2$year)
datos2 %>% 
  filter(month == 3) %>% 
  ggplot(aes(x = day, y = LAeq_d, col = day, group = day)) + geom_line() + geom_point() + labs(x = "Dias de marzo", y = "") + ggtitle("Ruido entre las 7h y las 19h")
datos2 %>% 
  filter(month == 3) %>%
  ggplot(aes(x = day, y = LAeq_e, col = day, group = day)) + geom_line() + geom_point() + labs(x = "Dias de marzo", y = "") + ggtitle("Ruido entre las 19h y las 23h")
datos2 %>% 
  filter(month == 3) %>%
  ggplot(aes(x = day, y = LAeq_n, col = day, group = day)) + geom_line() + geom_point() + labs(x = "Dias de marzo", y = "") + ggtitle("Ruido entre las 23h y las 7h")
```


#Fase 5. Acondicionamiento en tidy dataset

##Datos no variables

Comprobamos los datos que no varían y eliminamos las columnas. 

```{r}
datos<-datos[,-(3:5)]
```

##Nombres de las columnas

Renombramos las columnas con el fin de manejarlas más fácilmente y de que tengan un nombre más representativo.

```{r}
colnames(datos)<- c("id", "tiempo_grabacion", "r_continuo","r_7a19", "r_tardenoche", "r_19a23", "r_23a7","fecha_observacion", "calle")
```

##Tipos de las variables

Como hemos visto anteriormente en el análisis inicial de los datos, debemos cambiar la columna ahora llamada tiempo_grabacion a tipo factor, y la variable fecha_observacion a tipo fecha.

```{r}
summary(datos)
datos$tiempo_grabacion<-as.factor(datos$tiempo_grabacion)
datos$fecha_observacion<-as.Date(datos$fecha_observacion)
datos$calle<-as.factor(datos$calle)
```

##Datos faltantes

Vamos a ver si existen datos faltantes(NA) por si hay que corregirlos.

```{r}
sum(is.na(datos))
```
Como no existen datos faltantes(NA) no hace falta corregir nada.

##Valores infinitos

Hemos observado que existen valores infinitos en el maximo de r_7_19 y en r_19_23, así que vamos a imputar sus valores como el máximo de los demás:

```{r}
#Vemos que son infinitos
max(datos$r_7a19)
max(datos$r_19a23)

#Filas con los datos de infinito
datos %>% filter(r_7a19 == Inf | r_19a23 == Inf)

#Imputación
datos$r_7a19[which(datos$r_7a19==Inf)]<-max(datos$r_7a19[which(datos$r_7a19!=Inf)])
datos$r_19a23[which(datos$r_19a23==Inf)]<-max(datos$r_19a23[which(datos$r_19a23!=Inf)])
```
##Fecha Observación
Separamos la fecha de observación en 3 columnas (año, mes y día)
```{r}
datos <- separate(datos, col = fecha_observacion, into = c("year", "month", "day"), sep = "-")
datos$day <- as.numeric(datos$day)
datos$month <- as.numeric(datos$month)
datos$year <- as.numeric(datos$year)
```

##Clasificación por franja horaria.

Finalmente para que sea un correcto tidy dataset debemos definir el nivel de sonoridad en las horas en las que hemos grabado.

```{r}
datos<- gather(datos, key= Horario, value= Nivel_Sonoro ,3:7)
```

##Fase 6.Estadísticos, análisis, manipulación...
Finalmente, en esta fase nos dispondremos a analizar los datos de manera que podamos obtener la máxima información posible.


#Análisis Univariante
Comenzaremos esta fase con el análisis univariante. De este modo podremos conocer cómo se comportan nuestras variables.

Primero calcularemos la media del nivel sonoro.
```{r}
med_ns <- mean(datos$Nivel_Sonoro)
```
Como podemos observar, la media del nivel sonoro en todas las calles es de `r med_ns` dBA.

Seguidamente  calcularemos la mediana de la misma variable.

```{r}
mdn_ns <- median(datos$Nivel_Sonoro)
```

Así pues, podemos decir que la mediana del nivel sonoro es `r mdn_ns` dBA.

Podemos también calcular el rango para saber cuál es la diferencia entre el ruido más alto registrado y el más bajo. Aprovecharemos esto y calcularemos también el mínimo y el máximo. De este modo obtendremos el ruido más bajo registrado y el más alto.

```{r}
maxi <- max(datos$Nivel_Sonoro)
mini <- min(datos$Nivel_Sonoro)
rg <- maxi - mini
```

Tras estos cálculos observamos como el ruido más alto registrado se situó en `r maxi` dBA, en cambio el ruido más bajo rozó los `r mini` dBA. Por tanto, el rango es de `r rg` dBA. 

No obstante, necesitamos obtener un estadístico robusto, es por ello que procederemos a calcular el rango intercuartílico (diferencia entre el tercer y el primer cuartil de una distribución).
```{r}
iqr <- IQR(datos$Nivel_Sonoro)
```

Obtenemos que el Rango Intercuartil esá situado en `r iqr`. Al ser un valor relativamente bajo, podemos afirmar que los valores del nivel sonoro tienen poca dispersión. 

Para ver si los datos están agrupados entorno a su media, utilizaremos la desviación estándar.

```{r}
de <- sd(datos$Nivel_Sonoro)
```

El resultado de esta operación nos muestra un valor muy similar al del rango intercuartil; en este caso, la desviación toma un valor de `r de`. Es un valor relativamente bajo también, por lo que podemos afirmar que los valores que toma la variable, se encuentran cerca de su media.

Por último, para detectar posibles outliers podemos hacer un boxplot.

```{r}
boxplot(datos$Nivel_Sonoro, xlab = "Nivel Sonoro", ylab = "Valores", main = "Dispersión de los datos en la variable Nivel_Sonoro ")
```
En efecto se confirma lo que habíamos visto con los estadísticos calculados previamente, una desviación muy baja pero un rango bastante alto.



